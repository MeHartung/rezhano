<?php

namespace StoreBundle\Jstree;

/*use Accurateweb\ImageBundle\Exception\OptimizerNotFoundException;
use Accurateweb\ImageBundle\Optimizer\ImageOptimizer;*/



/**
 * Skeleton subclass for representing a row from the 'catalog_sections' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.6.4 on:
 *
 * 07/24/12 18:16:48
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    propel.generator.plugins.asIShopPlugin.lib.model.catalog
 */
class CatalogSection extends PluginCatalogSection
{
  const CONTEXT_SAVED_FILTER = 'saved-fitler';

  protected $sphinx_weight,
            $publishedSavedFilters = null,
            $filterRelations = null;

  
  /**
   * Возвращает название раздела для меню
   * @return string
   */
  public function getMenuDisplayName()
  {
    return ( $this->getMenuName() === null || trim($this->getMenuName()) == '') ?  $this->getName() : $this->getMenuName();
  }
  
  
  /**
   * Возвращает название раздела в хлебных крошках
   * @return string
   */
  public function getBreadcrumbsName() 
  {
    return $this->getMenuDisplayName();
  }
  
  
/*  public function getImageThumbs()
  {
    return array(
        "170x140" => array(
          'crop' => array(),
          "resize" => array("size" => "170x140")
        ),
        "144x119" => array(
          'crop' => array(),  
          "resize" => array("size" => "144x119")
        )
    );
  }*/

/*  public function setSphinxWeight($v)
  {
    $this->sphinx_weight = $v;
  }
  
  public function getSphinxWeight()
  {
    return $this->sphinx_weight;
  }

  public function getSphinxView()
  {
    return "catalog";
  }*/

  public function getUrl($absolute = false)
  {
    return sfContext::getInstance()->getController()->genUrl($this->getRoute(), $absolute);
  }

  public function getHref() //для плагина меню
  {
    return $this->getRoute();
  }

  public function getRoute(asBaseFilter $filter = null, $parameters = array())
  {
    return sprintf("@as_catalog_section?%s", http_build_query(array_merge(
            $filter ? $filter->getParameters() : array(),
            $parameters,
            array("slug" => $this->getSlug()))));
  }

  public function generateCriteria(Criteria $c = null, $recursive = true)
  {
    return $this->getProductQuery($c, $recursive);    
  }

  public function getProductQuery($criteria = null, $recursive = false)
  {
    return ProductQuery::create(null, $criteria)
            //->includeDeleted()
            ->useBindingQuery(null, Criteria::INNER_JOIN)
              ->_if($recursive)
                ->useCatalogSectionQuery(null, Criteria::INNER_JOIN)
                  ->branchOf($this)
                ->endUse()  
              ->_else()
                ->filterByCatalogSection($this)
              ->_endif()
            ->endUse()
            ->filterByPublished(true)
            ->groupById();
  }

  /**
   * Возвращает количество опубликованных товаров в разделе. Если в параметр $recursive передано значение true,
   * возвращает количество товаров в разделе и вложенных разделах
   * 
   * @param Criteria $criteria
   * @param boolean $recursive
   * @return int
   */
  public function getProductCount($criteria=null, $recursive=false)
  {
    return $this->getProductQuery($criteria, $recursive)
                ->_if($recursive)
                  ->groupById()
                ->_endif()
                ->count();
  }
  
  public function getKnowing()
  {
    return KnowingQuery::create()->filterByCatalogSection($this)->findOne();
  }

  public function getPublishedKnowledge()
  {
    return KnowingQuery::create()
      ->useKnowledgeBaseArticleToCatalogSectionQuery()
        ->filterByCatalogSection($this)
        ->orderBySortableRank()
      ->endUse()
      ->filterByPublished(true)
      ->find();
  }

  public function getClientModelValues($context = null)
  {
    sfContext::getInstance()->getLogger()->debug('CatalogSection::client'); 
      
    $image = $this->getImageThumb('170x140');

    $presentationId = $this->getPresentationId();
    if (null === $presentationId)
    {
        $presentation = $this->getPresentationProvider()->getDefaultPresentation($this);
        $presentationId = $presentation->getId();
    }
    else
    {
        $presentation = $this->getPresentationProvider()->getPresentationMap()->create($presentationId, $this);
    }
    
    $presentationOptions = CatalogSectionPresentationConfigurationManager::getInstance()
                                ->getCatalogSectionPresentationOptions($presentation);
    
    $values = array(
        'id' => $this->getId(),
        'name' => $this->getName(),
        'gepath' => $this->getGoogleEcommercePath(),
        'catalog_id' => $this->getCatalogId(),
        'url' => sfContext::getInstance()->getController()->genUrl($this->getRoute()),
        'alias' => $this->getAlias(),
        'image' => $image->file()->exists() ? $image->web()->url() : '/images/no_foto_170x140.png',
        'presentation_id' => $presentationId,
        'presentation_options' => $presentationOptions,
        'on_homepage' => $this->getOnHomepage(),
        'menu_name' => $this->getMenuName(),
        'name_genitive_plural' => $this->getNameGenitivePlural(),
        'nbProducts' => $this->getNbPublishedProducts(),
    );
    
   


    return $values;
  }

  public function preSave(PropelPDO $con = null)
  {
    if ($this->isNew() && !$this->getAlias())
    {
      $this->setAlias(AliasGenerator::generate('CatalogSection', $this, 'section'));
    }

    return parent::preSave($con);
  }

  public function getThumbnailsArray($absolute_path = false)
  {
    $thumbnails = array();
    
    $request = sfContext::getInstance()->getRequest();
    $prefix = 'http' . ($request->isSecure() ? 's' : '') . '://'. $request->getHost();

    foreach (array_keys($this->getImageThumbs()) as $thumbId)
    {
      $thumb = $this->getImageThumb($thumbId);
      if ($thumb->file()->exists())
      {
        $thumbnails[$thumbId] = $absolute_path ? $prefix . $thumb->web()->url() : $thumb->web()->url();
      }
    }

    $thumbnails['empty'] = $absolute_path ? $prefix . '/images/no_foto_110x90.png' : '/images/no_foto_110x90.png';

    return $thumbnails;
  }
  
  public function getPublishedSavedFilters()
  {
    if($this->publishedSavedFilters === null)
    {
      $filterQuery = SavedFilterQuery::create()
            ->filterByNbPublishedProducts(0, Criteria::GREATER_THAN)  
            ->filterByPublished(true)
            ->useCatalogSectionToSavedFilterQuery()
              ->orderByRank()
            ->endUse()
            ->groupById();
        
      $this->publishedSavadFilters = $this->getSavedFilters($filterQuery);
      
      if($this->publishedSavadFilters !== null)
      {
        $this->publishedSavadFilters->populateRelation('CatalogSectionToSavedFilter');  
      }
      
    }
      

    return $this->publishedSavadFilters;
  }
  
  
  public function getFilterRelations()
  {
      if($this->filterRelations === null)
      {
          $this->filterRelations = CatalogSectionToSavedFilterQuery::create()
                  ->useSavedFilterQuery()
                    ->filterByPublished(true)
                    ->filterByNbPublishedProducts(0, Criteria::GREATER_THAN)
                    ->groupById()    
                  ->endUse()
                  ->filterByCatalogSection($this)
                   
                  ->orderByRank()->find();
                  
      }
      
      return $this->filterRelations;
  }
  
  public function getSavedFilters($criteria = null, PropelPDO $con = null)
  {
    if (null === $criteria)
    {
      $criteria = new Criteria();
    }
    
    $criteria->addAnd(SavedFilterPeer::PUBLISHED, true);

    return parent::getSavedFilters($criteria, $con);
  }
  
    /**
     * Вычисляет значение вычислимого столбца nb_published_products 
     * 
     * @param PropelPDO $con A connection object
     *
     * @return mixed The scalar result from the aggregate query
     */
    public function computeNbPublishedProducts(PropelPDO $con)
    {
        $stmt = $con->prepare(''
                . 'SELECT COUNT(*) FROM (SELECT DISTINCT p.id FROM `catalog_sections` cs '
                . 'INNER JOIN `product_to_catalog_section` ptcs ON ptcs.catalog_section_id = cs.id '
                . 'INNER JOIN `products` p ON p.id = ptcs.product_id '
                . 'WHERE cs.tree_left >= :p1 AND cs.tree_right <= :p2 AND p.published > 0 AND p.deleted_at IS NULL) as `cnt`');
        
        $stmt->bindValue(':p1', $this->getTreeLeft());
        $stmt->bindValue(':p2', $this->getTreeRight());
        $stmt->execute();

        return $stmt->fetchColumn();
    }

    /**
     * Возвращает количество опубликованных товаров в разделе на основе данных из вычислимого столбца
     * nb_published_products. Если для указанного раздела эти данные не заполнены, вычисляет количество товаров 
     * в разделе и вложенных разделах
     * 
     * @return type
     */
    public function getNbPublishedProducts()
    {
      $nbPublishedProducts = parent::getNbPublishedProducts();
      if (null === $nbPublishedProducts)
      {
        $nbPublishedProducts = $this->getProductCount(null, true);
      }
      
      return $nbPublishedProducts;
    }
    
  /**
   * Возвращает true, если переданнный раздел находится в разделе "Запчасти", иначе false
   * 
   * @param IVirtualCategory $catalogSection Раздел каталога
   * @return boolean true, если указанный раздел каталога находится в разделе "Запчасти"
   */  
  static public function isPartsCatalogSection(IVirtualCategory $catalogSection)  
  {
    if ($catalogSection instanceof CatalogSection)
    {    
      $partsCatalogSectionId = asConfig::get('parts_catalog_section_id');
      if ($partsCatalogSectionId)
      {
        if ($catalogSection->getId() == $partsCatalogSectionId)
        {
          return true;
        }
        
        $partsCatalogSection = CatalogSectionQuery::create()->findOneById($partsCatalogSectionId);
        if (null !== $partsCatalogSection)
        {
          return $catalogSection->isDescendantOf($partsCatalogSection);
        }
      }
    }    
    return false;
  }

  /**
   * Возвращает true, если переданнный раздел находится в разделе "Спецодежда", иначе false
   *
   * @param IVirtualCategory $catalogSection Раздел каталога
   * @return boolean true, если указанный раздел каталога находится в разделе "Спецодежда"
   */
  static public function isСlothingCatalogSection(IVirtualCategory $catalogSection)
  {
    if ($catalogSection instanceof CatalogSection)
    {
      $clothingCatalogSectionId = asConfig::get('clothing_catalog_section_id');
      if ($clothingCatalogSectionId)
      {
        if ($catalogSection->getId() == $clothingCatalogSectionId)
        {
          return true;
        }

        $clothingCatalogSectionId = CatalogSectionQuery::create()->findOneById($clothingCatalogSectionId);
        if (null !== $clothingCatalogSectionId)
        {
          return $catalogSection->isDescendantOf($clothingCatalogSectionId);
        }
      }
    }
    return false;
  }
  
  public function compare(CatalogSection $_b)
  {
    if ($this->getName() == $_b->getName())
    {
      return 0;
    }
    
    return ($this->getName() < $_b->getName()) ? -1 : 1;
  }
  
  /**
   * Определяет, содержится ли указанный товар в разделе каталога
   * 
   * @param Product $product
   * @return boolean TRUE, если раздел содержит заданный товар, иначе FALSE
   */
  public function containsProduct(Product $product)
  {    
    return ProductToCatalogSectionQuery::create()
             ->filterByProduct($product)
             ->filterByCatalogSection($this)
             ->limit(1)
             ->count() > 0;
  }

  /**
   * Возвращает разделы каталога, находящиеся на одном уровне с текущим и имеющие с ним общего родителя, доступные
   * для отображения в каталоге, т.е. имеющие хотя бы один опубликованный товар
   * 
   * @param boolean  $includeNode Указывает, включать ли в результат текущий узел
   * @param Criteria $query Дополнительный критерий отбора результатов
   * @param PropelPDO $con Соединение, которое следует использовать
   * 
   * @return PropelObjectCollection|array Коллекция объектов
   */
  public function getSiblingsToDisplay($includeNode = false, $query = null, PropelPDO $con=null)
  {
    $catalogSectionQuery = CatalogSectionQuery::create(null, $query)
                             ->filterByNbPublishedProducts(0, Criteria::GREATER_THAN);
    
    return $this->getSiblings($includeNode, $catalogSectionQuery, $con);
  }  
  
  public function getIcon()
  {
    $icon = parent::getIcon();
    
    if (null !== $icon)
    {
      $icon = json_decode($icon, true);
      return new FontIcon($icon['ccode'], $icon['class']);
    }
    
    return null;
  }
  
  public function setIcon($v)
  {
    if (null !== $v)
    {
      if ($v instanceof FontIcon)
      {
        $v = array('ccode' => $v->getCharCode(), 'class' => $v->getHtmlClassName());
      }
      if (is_array($v))
      {
        $v = json_encode($v);
      }
      else
      {
        throw new InvalidArgumentException();
      }
    }
    
    return parent::setIcon($v);
  }
  
  /**
   * Возвращает путь до указанного раздела в дереве каталога для Google Ecommerce
   * 
   * @param String $delimiter
   * @return String
   */
  public function getGoogleEcommercePath($delimiter='/')
  {    
    $pathParts = CatalogSectionQuery::create()
                    ->filterByTreeLevel(1, Criteria::GREATER_THAN)
                    ->ancestorsOf($this)
                    ->orderByLevel(false)                
                    ->limit(5)
                    ->select('Name')
                    ->find()
                    ->getData();
    
    $pathParts[] = $this->getName();
    
    return implode($delimiter, $pathParts);
  }
  
  public function getCatalogSectionPresentationOptions(CatalogSectionPresentationBase $presentation)
  {
    return CatalogSectionPresentationConfigurationManager::getInstance()
             ->getCatalogSectionPresentationOptions($presentation, $this);
  }
  
  /**
   * Возвращает полный путь до раздела в виде строки, разделенной заданным разделителем
   * 
   * @param String $delimiter Разделитель
   * @return String Полный путь до раздела
   */
  public function getStringPath($delimiter='/')
  {
    return implode($delimiter, CatalogSectionQuery::create()
                   ->rootsOf($this)
                   ->filterByTreeLevel(['min' => 2])
                   ->orderByTreeLevel()                    
                   ->select('Name')
                   ->find()
                   ->getData());
  }
  
  
  /**
   * Оптимизрует изображение после сохранения
   * 
   * @param sfImage $image
   */  
  public function postProcessImage(sfImage $image)
  {
    try
    {
      ImageOptimizer::createInstance($image->getFilename())->optimize();
    }
    catch (OptimizerNotFoundException $e)
    {
      if (sfContext::hasInstance())
      {
        sfContext::getInstance()->getLogger()->err($e->getMessage());
      }
    }  
  }

}